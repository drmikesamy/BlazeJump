@page "/"
@using BlazeJump.Client.Pages.Components
@using BlazeJump.Client.Services.Connections;
@using BlazeJump.Client.Models;
@using BlazeJump.Client.Services.Crypto;
@using BlazeJump.Client.Services.Message;
@using BlazeJump.Client.Services.UserProfile;
@inject IRelayManager RelayManager
@inject IMessageService MessageService
@inject ICryptoService CryptoService


<div class="loading-modal" style="@(Loading ? "display: block" : "display: none")">
	@foreach(var Connection in RelayManager.RelayConnections)
	{
		@Connection.Key
		<br />
	}
</div>

<div class="box">
	<div>
		<input type="text" id="new-message" name="new-message" @bind="NewNEventInput"><button type="button" @onclick="SendNEvent">Send</button>
	</div>
</div>
@foreach (var message in MessageList)
{
	<MessageCard Message=message></MessageCard>
}

@code {
	public bool Loading { get; set; } = false;
	public string NewNEventInput { get; set; } = string.Empty;
	public List<NEvent> MessageList { get; set; } = new List<NEvent>();
	public bool SubscriptionLoadingHidden { get; set; } = true;
	public Dictionary<string, bool> ActiveSubscriptions = new Dictionary<string, bool>();
	protected override async Task OnInitializedAsync()
	{
		Loading = true;
		await GetMessagesByFilter(DateTime.UtcNow.AddDays(-7), DateTime.Now.AddDays(1));
		Loading = false;
	}

	public async Task SendNEvent()
	{
		var newNEvent = await MessageService.GetNewNEvent(Enums.KindEnum.Text, NewNEventInput, null);
		await MessageService.SendNEvent(newNEvent, ActiveSubscriptions.Keys.First());
	}

	public async Task GetMessagesByFilter(DateTime since, DateTime until)
	{
		SubscriptionLoadingHidden = false;

		var ownPubKey = await CryptoService.GetPublicKey();

		var filter = new Filter
			{
				Since = since,
				Until = until,
				Authors = new List<string>(),
			};

		//Jack's key
		filter.Authors.Add("82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2");

		//Own key
		if(ownPubKey != null)
		{
			filter.Authors.Add(ownPubKey);
		}

		MessageList = await MessageService.FetchMessagesByFilter(filter);

		StateHasChanged();
	}
}